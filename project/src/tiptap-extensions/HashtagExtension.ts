// AI-NOTICE: Generated by Claude 3.7 Sonnet, mode: concise, chats: 3, messages: 10+
import { Mark } from '@tiptap/core'
import { Plugin, PluginKey } from 'prosemirror-state'

export interface HashtagOptions {
    HTMLAttributes: Record<string, any>
    hashtagLength: number
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        hashtag: {
            /**
             * Set a hashtag mark
             */
            setHashtag: () => ReturnType
            /**
             * Toggle a hashtag mark
             */
            toggleHashtag: () => ReturnType
            /**
             * Unset a hashtag mark
             */
            unsetHashtag: () => ReturnType
        }
    }
}

export const Hashtag = Mark.create<HashtagOptions>({
    name: 'hashtag',

    addOptions() {
        return {
            HTMLAttributes: {},
            hashtagLength: 20,
        }
    },

    parseHTML() {
        return [
            {
                tag: 'span[data-hashtag]',
            },
        ]
    },

    renderHTML({ HTMLAttributes }) {
        return ['span', { ...HTMLAttributes, 'data-hashtag': '', class: 'hashtag-mark' }, 0]
    },

    addCommands() {
        return {
            setHashtag:
                () =>
                ({ commands }) => {
                    return commands.setMark(this.name)
                },
            toggleHashtag:
                () =>
                ({ commands }) => {
                    return commands.toggleMark(this.name)
                },
            unsetHashtag:
                () =>
                ({ commands }) => {
                    return commands.unsetMark(this.name)
                },
        }
    },

    addProseMirrorPlugins() {
        const pluginKey = new PluginKey('hashtag')
        // Modified regex to better isolate individual hashtags
        const hashtagRegex = new RegExp(
            `(#[A-Za-z0-9_-]{1,${this.options.hashtagLength}})(?=[^A-Za-z0-9_-]|$)`,
            'g',
        )

        return [
            new Plugin({
                key: pluginKey,
                appendTransaction: (transactions, oldState, newState) => {
                    // Skip if there are no transactions or none of them change the doc
                    if (!transactions.some((tr) => tr.docChanged)) return null

                    // Skip if this is a history-related transaction
                    if (transactions.some((tr) => tr.getMeta('history$'))) return null

                    // Skip if we're already processing hashtags to prevent infinite loops
                    if (transactions.some((tr) => tr.getMeta('addingHashtagMarks'))) return null

                    const { doc, schema, tr } = newState
                    const markType = schema.marks.hashtag

                    // Create a new transaction
                    const transaction = tr.setMeta('addingHashtagMarks', true)

                    // First remove all hashtag marks
                    doc.descendants((node, pos) => {
                        if (!node.isText) return
                        if (node.marks.some((mark) => mark.type === markType)) {
                            transaction.removeMark(pos, pos + node.nodeSize, markType)
                        }
                    })

                    // Collect all hashtags
                    const hashtags: { from: number; to: number }[] = []

                    // Find hashtags
                    doc.descendants((node, pos) => {
                        if (!node.isText) return

                        const text = node.text || ''

                        // Reset and use regex to find all matches
                        hashtagRegex.lastIndex = 0
                        let match

                        while ((match = hashtagRegex.exec(text)) !== null) {
                            const from = pos + match.index
                            const to = from + match[1].length

                            hashtags.push({ from, to })
                        }
                    })

                    // Check for consecutive hashtags and handle insertion of spaces between them
                    for (let i = 0; i < hashtags.length - 1; i++) {
                        const current = hashtags[i]
                        const next = hashtags[i + 1]

                        // If hashtags are consecutive (end of one is start of another)
                        if (current.to === next.from) {
                            // Insert a space between them
                            transaction.insertText(' ', current.to)

                            // Adjust positions of all subsequent hashtags
                            for (let j = i + 1; j < hashtags.length; j++) {
                                hashtags[j].from += 1
                                hashtags[j].to += 1
                            }
                        }
                    }

                    // Now add marks for each hashtag
                    hashtags.forEach(({ from, to }) => {
                        transaction.addMark(from, to, markType.create())
                    })

                    return transaction.steps.length ? transaction : null
                },
                // Add handling for real-time input
                view(view) {
                    return {
                        update(view, prevState) {
                            const { state } = view
                            const { selection } = state
                            const markType = state.schema.marks.hashtag

                            // Check if character just typed could create a consecutive hashtag situation
                            const { $head } = selection
                            if ($head && $head.nodeBefore && $head.nodeBefore.isText) {
                                const text = $head.nodeBefore.text || ''
                                // If we just typed a # character
                                if (text.endsWith('#') && text.length > 1) {
                                    // Look at character before the #
                                    const prevChar = text[text.length - 2]

                                    // Check if the previous character is part of a hashtag
                                    // by checking if it has a hashtag mark
                                    const prevPos = $head.pos - 2
                                    let hasHashtagMark = false

                                    // Ensure we're in range before checking
                                    if (prevPos >= 0) {
                                        state.doc.nodesBetween(
                                            prevPos,
                                            prevPos + 1,
                                            (node, pos) => {
                                                if (
                                                    node.isText &&
                                                    node.marks.some(
                                                        (mark) => mark.type === markType,
                                                    )
                                                ) {
                                                    hasHashtagMark = true
                                                }
                                            },
                                        )
                                    }

                                    // Only insert a space if the previous character is part of a hashtag
                                    if (hasHashtagMark) {
                                        const tr = state.tr.insertText(' ', $head.pos - 1)
                                        view.dispatch(tr)
                                    }
                                }
                            }
                        },
                    }
                },
            }),
        ]
    },
})
